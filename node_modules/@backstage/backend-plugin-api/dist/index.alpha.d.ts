/**
 * Core API used by Backstage backend plugins.
 *
 * @packageDocumentation
 */

import { Config } from '@backstage/config';
import { Handler } from 'express';
import { Logger } from 'winston';
import { PermissionAuthorizer } from '@backstage/plugin-permission-common';
import { PermissionEvaluator } from '@backstage/plugin-permission-common';
import { PluginCacheManager } from '@backstage/backend-common';
import { PluginDatabaseManager } from '@backstage/backend-common';
import { PluginEndpointDiscovery } from '@backstage/backend-common';
import { PluginTaskScheduler } from '@backstage/backend-tasks';
import { TokenManager } from '@backstage/backend-common';
import { TransportStreamOptions } from 'winston-transport';
import { UrlReader } from '@backstage/backend-common';

/** @public */
export declare interface BackendFeature {
    id: string;
    register(reg: BackendRegistrationPoints): void;
}

/** @public */
export declare interface BackendModuleConfig<TOptions> {
    pluginId: string;
    moduleId: string;
    register(reg: Omit<BackendRegistrationPoints, 'registerExtensionPoint'>, options: TOptions): void;
}

/** @public */
export declare interface BackendPluginConfig<TOptions> {
    id: string;
    register(reg: BackendRegistrationPoints, options: TOptions): void;
}

/** @public */
export declare interface BackendRegistrationPoints {
    registerExtensionPoint<TExtensionPoint>(ref: ExtensionPoint<TExtensionPoint>, impl: TExtensionPoint): void;
    registerInit<Deps extends {
        [name in string]: unknown;
    }>(options: {
        deps: {
            [name in keyof Deps]: ServiceRef<Deps[name]> | ExtensionPoint<Deps[name]>;
        };
        init(deps: Deps): Promise<void>;
    }): void;
}

/** @public */
export declare type CacheService = PluginCacheManager;

/**
 * @public
 */
declare const cacheServiceRef: ServiceRef<PluginCacheManager, "plugin">;

/**
 * @public
 */
export declare type ConfigService = Config;

/**
 * @public
 */
declare const configServiceRef: ServiceRef<Config, "root">;

declare namespace coreServices {
    export {
        configServiceRef as config,
        httpRouterServiceRef as httpRouter,
        loggerServiceRef as logger,
        urlReaderServiceRef as urlReader,
        cacheServiceRef as cache,
        databaseServiceRef as database,
        discoveryServiceRef as discovery,
        tokenManagerServiceRef as tokenManager,
        permissionsServiceRef as permissions,
        schedulerServiceRef as scheduler,
        rootLoggerServiceRef as rootLogger,
        pluginMetadataServiceRef as pluginMetadata,
        lifecycleServiceRef as lifecycle
    }
}
export { coreServices }

/**
 * @public
 *
 * Creates a new backend module for a given plugin.
 *
 * The `moduleId` should be equal to the module-specific prefix of the exported name, such
 * that the full name is `moduleId + PluginId + "Module"`. For example, a GitHub entity
 * provider module for the `catalog` plugin might have the module ID `'githubEntityProvider'`,
 * and the full exported name would be `githubEntityProviderCatalogModule`.
 *
 * The `pluginId` should exactly match the `id` of the plugin that the module extends.
 */
export declare function createBackendModule<TOptions extends object | undefined = undefined>(config: BackendModuleConfig<TOptions>): undefined extends TOptions ? (options?: TOptions) => BackendFeature : (options: TOptions) => BackendFeature;

/** @public */
export declare function createBackendPlugin<TOptions extends object | undefined = undefined>(config: {
    id: string;
    register(reg: BackendRegistrationPoints, options: TOptions): void;
}): undefined extends TOptions ? (options?: TOptions) => BackendFeature : (options: TOptions) => BackendFeature;

/** @public */
export declare function createExtensionPoint<T>(options: {
    id: string;
}): ExtensionPoint<T>;

/**
 * @public
 */
export declare function createServiceFactory<TService, TScope extends 'root' | 'plugin', TImpl extends TService, TDeps extends {
    [name in string]: ServiceRef<unknown>;
}, TOpts extends object | undefined = undefined>(config: {
    service: ServiceRef<TService, TScope>;
    deps: TDeps;
    factory(deps: ServiceRefsToInstances<TDeps, 'root'>, options: TOpts): TScope extends 'root' ? Promise<TImpl> : Promise<(deps: ServiceRefsToInstances<TDeps>) => Promise<TImpl>>;
}): undefined extends TOpts ? (options?: TOpts) => ServiceFactory<TService> : (options: TOpts) => ServiceFactory<TService>;

/** @public */
export declare function createServiceRef<T>(options: {
    id: string;
    scope?: 'plugin';
    defaultFactory?: (service: ServiceRef<T, 'plugin'>) => Promise<ServiceFactory<T> | (() => ServiceFactory<T>)>;
}): ServiceRef<T, 'plugin'>;

/** @public */
export declare function createServiceRef<T>(options: {
    id: string;
    scope: 'root';
    defaultFactory?: (service: ServiceRef<T, 'root'>) => Promise<ServiceFactory<T> | (() => ServiceFactory<T>)>;
}): ServiceRef<T, 'root'>;

/** @public */
export declare type DatabaseService = PluginDatabaseManager;

/**
 * @public
 */
declare const databaseServiceRef: ServiceRef<PluginDatabaseManager, "plugin">;

/** @public */
export declare type DiscoveryService = PluginEndpointDiscovery;

/**
 * @public
 */
declare const discoveryServiceRef: ServiceRef<PluginEndpointDiscovery, "plugin">;

/**
 * TODO
 *
 * @public
 */
export declare type ExtensionPoint<T> = {
    id: string;
    /**
     * Utility for getting the type of the extension point, using `typeof extensionPoint.T`.
     * Attempting to actually read this value will result in an exception.
     */
    T: T;
    toString(): string;
    $$ref: 'extension-point';
};

/**
 * @public
 */
export declare interface HttpRouterService {
    use(handler: Handler): void;
}

/**
 * @public
 */
declare const httpRouterServiceRef: ServiceRef<HttpRouterService, "plugin">;

/**
 * @public
 **/
export declare interface LifecycleService {
    /**
     * Register a function to be called when the backend is shutting down.
     */
    addShutdownHook(options: LifecycleServiceShutdownHook): void;
}

/**
 * @public
 */
declare const lifecycleServiceRef: ServiceRef<LifecycleService, "plugin">;

/**
 * @public
 **/
export declare type LifecycleServiceShutdownHook = {
    fn: () => void | Promise<void>;
};

/**
 * @public
 */
export declare interface LoggerService {
    error(message: string, meta?: Error | LogMeta): void;
    warn(message: string, meta?: Error | LogMeta): void;
    info(message: string, meta?: Error | LogMeta): void;
    debug(message: string, meta?: Error | LogMeta): void;
    child(meta: LogMeta): LoggerService;
}

/**
 * @public
 */
declare const loggerServiceRef: ServiceRef<LoggerService, "plugin">;

/** @public */
export declare function loggerToWinstonLogger(logger: LoggerService, opts?: TransportStreamOptions): Logger;

/**
 * @public
 */
export declare type LogMeta = {
    [name: string]: unknown;
};

/** @public */
export declare type PermissionsService = PermissionEvaluator | PermissionAuthorizer;

/**
 * @public
 */
declare const permissionsServiceRef: ServiceRef<PermissionsService, "plugin">;

/**
 * @public
 */
export declare interface PluginMetadataService {
    getId(): string;
}

/**
 * @public
 */
declare const pluginMetadataServiceRef: ServiceRef<PluginMetadataService, "plugin">;

/** @public */
export declare type RootLoggerService = LoggerService;

/**
 * @public
 */
declare const rootLoggerServiceRef: ServiceRef<LoggerService, "root">;

/** @public */
export declare type SchedulerService = PluginTaskScheduler;

/**
 * @public
 */
declare const schedulerServiceRef: ServiceRef<PluginTaskScheduler, "plugin">;

/** @public */
export declare type ServiceFactory<TService = unknown> = {
    scope: 'root';
    service: ServiceRef<TService, 'root'>;
    deps: {
        [key in string]: ServiceRef<unknown>;
    };
    factory(deps: {
        [key in string]: unknown;
    }): Promise<TService>;
} | {
    scope: 'plugin';
    service: ServiceRef<TService, 'plugin'>;
    deps: {
        [key in string]: ServiceRef<unknown>;
    };
    factory(deps: {
        [key in string]: unknown;
    }): Promise<(deps: {
        [key in string]: unknown;
    }) => Promise<TService>>;
};

/**
 * TODO
 *
 * @public
 */
export declare type ServiceRef<TService, TScope extends 'root' | 'plugin' = 'root' | 'plugin'> = {
    id: string;
    /**
     * This determines the scope at which this service is available.
     *
     * Root scoped services are available to all other services but
     * may only depend on other root scoped services.
     *
     * Plugin scoped services are only available to other plugin scoped
     * services but may depend on all other services.
     */
    scope: TScope;
    /**
     * Utility for getting the type of the service, using `typeof serviceRef.T`.
     * Attempting to actually read this value will result in an exception.
     */
    T: TService;
    toString(): string;
    $$ref: 'service';
};

/** @ignore */
declare type ServiceRefsToInstances<T extends {
    [key in string]: ServiceRef<unknown>;
}, TScope extends 'root' | 'plugin' = 'root' | 'plugin'> = {
    [name in {
        [key in keyof T]: T[key] extends ServiceRef<unknown, TScope> ? key : never;
    }[keyof T]]: T[name] extends ServiceRef<infer TImpl> ? TImpl : never;
};

/** @public */
export declare type TokenManagerService = TokenManager;

/**
 * @public
 */
declare const tokenManagerServiceRef: ServiceRef<TokenManager, "plugin">;

/** @public */
export declare type TypesToServiceRef<T> = {
    [key in keyof T]: ServiceRef<T[key]>;
};

/** @public */
export declare type UrlReaderService = UrlReader;

/**
 * @public
 */
declare const urlReaderServiceRef: ServiceRef<UrlReader, "plugin">;

export { }
