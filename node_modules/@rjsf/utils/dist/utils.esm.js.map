{"version":3,"file":"utils.esm.js","sources":["../src/isObject.ts","../src/allowAdditionalItems.ts","../src/asNumber.ts","../src/constants.ts","../src/getUiOptions.ts","../src/canExpand.ts","../src/deepEquals.ts","../src/findSchemaDefinition.ts","../src/schema/getMatchingOption.ts","../src/guessType.ts","../src/getSchemaType.ts","../src/isFixedItems.ts","../src/mergeDefaultsWithFormData.ts","../src/mergeObjects.ts","../src/isConstant.ts","../src/mergeSchemas.ts","../src/schema/retrieveSchema.ts","../src/schema/isSelect.ts","../src/schema/isMultiSelect.ts","../src/schema/getDefaultFormState.ts","../src/isCustomWidget.ts","../src/schema/isFilesArray.ts","../src/schema/getDisplayLabel.ts","../src/schema/mergeValidationData.ts","../src/schema/toIdSchema.ts","../src/schema/toPathSchema.ts","../src/createSchemaUtils.ts","../src/dataURItoBlob.ts","../src/ErrorSchemaBuilder.ts","../src/rangeSpec.ts","../src/getInputProps.ts","../src/getSubmitButtonOptions.ts","../src/getTemplate.ts","../src/getWidget.tsx","../src/hasWidget.ts","../src/localToUTC.ts","../src/toConstant.ts","../src/optionsList.ts","../src/orderProperties.ts","../src/pad.ts","../src/parseDateString.ts","../src/processSelectValue.ts","../src/schemaRequiresTrueValue.ts","../src/shouldRender.ts","../src/toDateString.ts","../src/utcToLocal.ts"],"sourcesContent":["/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n  if (typeof Date !== \"undefined\" && thing instanceof Date) {\n    return false;\n  }\n  return typeof thing === \"object\" && thing !== null && !Array.isArray(thing);\n}\n","import isObject from \"./isObject\";\nimport { RJSFSchema, StrictRJSFSchema } from \"./types\";\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems<\n  S extends StrictRJSFSchema = RJSFSchema\n>(schema: S) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n  return isObject(schema.additionalItems);\n}\n","/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === \"\") {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === \"number\" && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n","/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\nexport const ADDITIONAL_PROPERTIES_KEY = \"additionalProperties\";\nexport const ALL_OF_KEY = \"allOf\";\nexport const ANY_OF_KEY = \"anyOf\";\nexport const CONST_KEY = \"const\";\nexport const DEFAULT_KEY = \"default\";\nexport const DEFINITIONS_KEY = \"definitions\";\nexport const DEPENDENCIES_KEY = \"dependencies\";\nexport const ENUM_KEY = \"enum\";\nexport const ERRORS_KEY = \"__errors\";\nexport const ID_KEY = \"$id\";\nexport const ITEMS_KEY = \"items\";\nexport const NAME_KEY = \"$name\";\nexport const ONE_OF_KEY = \"oneOf\";\nexport const PROPERTIES_KEY = \"properties\";\nexport const REQUIRED_KEY = \"required\";\nexport const SUBMIT_BTN_OPTIONS_KEY = \"submitButtonOptions\";\nexport const REF_KEY = \"$ref\";\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = \"__rjsf_additionalProperties\";\nexport const UI_FIELD_KEY = \"ui:field\";\nexport const UI_WIDGET_KEY = \"ui:widget\";\nexport const UI_OPTIONS_KEY = \"ui:options\";\n","import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from \"./constants\";\nimport isObject from \"./isObject\";\nimport {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UIOptionsType,\n  UiSchema,\n} from \"./types\";\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @returns - An object containing all the `ui:xxx` options with the stripped off\n */\nexport default function getUiOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UIOptionsType<T, S, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf(\"ui:\") === 0)\n    .reduce((options, key) => {\n      const value = uiSchema[key];\n      if (key === UI_WIDGET_KEY && isObject(value)) {\n        console.error(\n          \"Setting options via ui:widget object is no longer supported, use ui:options instead\"\n        );\n        return options;\n      }\n      if (key === UI_OPTIONS_KEY && isObject(value)) {\n        return { ...options, ...value };\n      }\n      return { ...options, [key.substring(3)]: value };\n    }, {});\n}\n","import {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n} from \"./types\";\nimport getUiOptions from \"./getUiOptions\";\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(schema: RJSFSchema, uiSchema: UiSchema<T, S, F> = {}, formData?: T) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n","import isEqualWith from \"lodash/isEqualWith\";\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === \"function\" && typeof other === \"function\") {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n","import jsonpointer from \"jsonpointer\";\nimport omit from \"lodash/omit\";\n\nimport { REF_KEY } from \"./constants\";\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from \"./types\";\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(\n  key: string,\n  object: GenericObjectType\n) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition<\n  S extends StrictRJSFSchema = RJSFSchema\n>($ref?: string, rootSchema: S = {} as S): S {\n  let ref = $ref || \"\";\n  if (ref.startsWith(\"#\")) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n","import { RJSFSchema, StrictRJSFSchema, ValidatorType } from \"../types\";\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @returns - The index of the matched option or 0 if none is available\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n","/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return \"array\";\n  }\n  if (typeof value === \"string\") {\n    return \"string\";\n  }\n  if (value == null) {\n    return \"null\";\n  }\n  if (typeof value === \"boolean\") {\n    return \"boolean\";\n  }\n  if (!isNaN(value)) {\n    return \"number\";\n  }\n  if (typeof value === \"object\") {\n    return \"object\";\n  }\n  // Default to string if we can't figure it out\n  return \"string\";\n}\n","import guessType from \"./guessType\";\nimport { RJSFSchema, StrictRJSFSchema } from \"./types\";\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (Array.isArray(type) && type.length === 2 && type.includes(\"null\")) {\n    type = type.find((type) => type !== \"null\");\n  }\n\n  return type;\n}\n","import isObject from \"./isObject\";\nimport { RJSFSchema, StrictRJSFSchema } from \"./types\";\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n) {\n  return (\n    Array.isArray(schema.items) &&\n    schema.items.length > 0 &&\n    schema.items.every((item) => isObject(item))\n  );\n}\n","import get from \"lodash/get\";\n\nimport isObject from \"./isObject\";\nimport { GenericObjectType } from \"../src\";\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param defaults - The defaults to merge\n * @param formData - The form data into which the defaults will be merged\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(\n  defaults: T,\n  formData: T\n): T {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value);\n      }\n      return value;\n    });\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\n        defaults ? get(defaults, key) : {},\n        get(formData, key)\n      );\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n","import isObject from \"./isObject\";\nimport { GenericObjectType } from \"./types\";\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\n *          NOTE: Uses shallow comparison for the duplicate checking.\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays: boolean | \"preventDuplicates\" = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      let toMerge = right;\n      if (concatArrays === \"preventDuplicates\") {\n        toMerge = right.reduce((result, value) => {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n          return result;\n        }, []);\n      }\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n","import { CONST_KEY } from \"./constants\";\nimport { RJSFSchema, StrictRJSFSchema } from \"./types\";\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n) {\n  return (\n    (Array.isArray(schema.enum) && schema.enum.length === 1) ||\n    CONST_KEY in schema\n  );\n}\n","import union from \"lodash/union\";\n\nimport { REQUIRED_KEY } from \"./constants\";\nimport getSchemaType from \"./getSchemaType\";\nimport isObject from \"./isObject\";\nimport { GenericObjectType } from \"./types\";\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType\n) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === \"object\" || getSchemaType(obj2) === \"object\") &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n","import get from \"lodash/get\";\nimport set from \"lodash/set\";\nimport mergeAllOf, { Options } from \"json-schema-merge-allof\";\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  DEPENDENCIES_KEY,\n  REF_KEY,\n} from \"../constants\";\nimport findSchemaDefinition, {\n  splitKeyElementFromObject,\n} from \"../findSchemaDefinition\";\nimport guessType from \"../guessType\";\nimport isObject from \"../isObject\";\nimport mergeSchemas from \"../mergeSchemas\";\nimport {\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from \"../types\";\nimport getMatchingOption from \"./getMatchingOption\";\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param formData - The current formData to assist retrieving a schema\n * @returns - A schema with the appropriate condition resolved\n */\nexport function resolveCondition<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(validator: ValidatorType<T, S>, schema: S, rootSchema: S, formData: T) {\n  const {\n    if: expression,\n    then,\n    else: otherwise,\n    ...resolvedSchemaLessConditional\n  } = schema;\n\n  const conditionalSchema = validator.isValid(\n    expression as S,\n    formData,\n    rootSchema\n  )\n    ? then\n    : otherwise;\n\n  if (conditionalSchema && typeof conditionalSchema !== \"boolean\") {\n    return retrieveSchema<T, S>(\n      validator,\n      mergeSchemas(\n        resolvedSchemaLessConditional,\n        retrieveSchema(validator, conditionalSchema, rootSchema, formData)\n      ) as S,\n      rootSchema,\n      formData\n    );\n  }\n  return retrieveSchema<T, S>(\n    validator,\n    resolvedSchemaLessConditional as S,\n    rootSchema,\n    formData\n  );\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children.\n * Called internally by retrieveSchema.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its references and dependencies resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema>(\n  validator: ValidatorType<T, S>,\n  schema: S,\n  rootSchema: S = {} as S,\n  formData?: T\n): S {\n  if (REF_KEY in schema) {\n    return resolveReference<T, S>(validator, schema, rootSchema, formData);\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S>(\n      validator,\n      schema,\n      rootSchema,\n      formData\n    );\n    return retrieveSchema<T, S>(\n      validator,\n      resolvedSchema,\n      rootSchema,\n      formData\n    );\n  }\n  if (ALL_OF_KEY in schema) {\n    return {\n      ...schema,\n      allOf: schema.allOf!.map((allOfSubschema) =>\n        retrieveSchema<T, S>(\n          validator,\n          allOfSubschema as S,\n          rootSchema,\n          formData\n        )\n      ),\n    };\n  }\n  // No $ref or dependencies attribute found, returning the original schema.\n  return schema;\n}\n\n/** Resolves references within a schema and its 'allOf' children.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its references resolved\n */\nexport function resolveReference<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(validator: ValidatorType<T, S>, schema: S, rootSchema: S, formData?: T): S {\n  // Retrieve the referenced schema definition.\n  const $refSchema = findSchemaDefinition<S>(schema.$ref, rootSchema);\n  // Drop the $ref property of the source schema.\n  const { $ref, ...localSchema } = schema;\n  // Update referenced schema definition with local schema properties.\n  return retrieveSchema<T, S>(\n    validator,\n    { ...$refSchema, ...localSchema },\n    rootSchema,\n    formData\n  );\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  theSchema: S,\n  rootSchema?: S,\n  aFormData?: T\n): S {\n  // Clone the schema so we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType =\n    aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S[\"additionalProperties\"] = {};\n    if (typeof schema.additionalProperties !== \"boolean\") {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if (\"type\" in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  schema: S,\n  rootSchema: S = {} as S,\n  rawFormData?: T\n): S {\n  if (!isObject(schema)) {\n    return {} as S;\n  }\n  let resolvedSchema = resolveSchema<T, S>(\n    validator,\n    schema,\n    rootSchema,\n    rawFormData\n  );\n\n  if (\"if\" in schema) {\n    return resolveCondition<T, S>(\n      validator,\n      schema,\n      rootSchema,\n      rawFormData as T\n    );\n  }\n\n  const formData: GenericObjectType = rawFormData || {};\n\n  if (ALL_OF_KEY in schema) {\n    try {\n      resolvedSchema = mergeAllOf(resolvedSchema, {\n        deep: false,\n      } as Options) as S;\n    } catch (e) {\n      console.warn(\"could not merge subschemas in allOf:\\n\" + e);\n      const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n      return resolvedSchemaWithoutAllOf as S;\n    }\n  }\n  const hasAdditionalProperties =\n    ADDITIONAL_PROPERTIES_KEY in resolvedSchema &&\n    resolvedSchema.additionalProperties !== false;\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties<T, S>(\n      validator,\n      resolvedSchema,\n      rootSchema,\n      formData as T\n    );\n  }\n  return resolvedSchema;\n}\n\n/** Resolves dependencies within a schema and its 'allOf' children.\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with its dependencies resolved\n */\nexport function resolveDependencies<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(validator: ValidatorType<T, S>, schema: S, rootSchema: S, formData?: T): S {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  let resolvedSchema: S = remainingSchema as S;\n  if (Array.isArray(resolvedSchema.oneOf)) {\n    resolvedSchema = resolvedSchema.oneOf[\n      getMatchingOption<T, S>(\n        validator,\n        formData,\n        resolvedSchema.oneOf as S[],\n        rootSchema\n      )\n    ] as S;\n  } else if (Array.isArray(resolvedSchema.anyOf)) {\n    resolvedSchema = resolvedSchema.anyOf[\n      getMatchingOption<T, S>(\n        validator,\n        formData,\n        resolvedSchema.anyOf as S[],\n        rootSchema\n      )\n    ] as S;\n  }\n  return processDependencies<T, S>(\n    validator,\n    dependencies,\n    resolvedSchema,\n    rootSchema,\n    formData\n  );\n}\n\n/** Processes all the `dependencies` recursively into the `resolvedSchema` as needed\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  dependencies: S[\"dependencies\"],\n  resolvedSchema: S,\n  rootSchema: S,\n  formData?: T\n): S {\n  let schema = resolvedSchema;\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (schema.properties && !(dependencyKey in schema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schema = withDependentProperties(schema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schema = withDependentSchema<T, S>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        formData\n      );\n    }\n    return processDependencies<T, S>(\n      validator,\n      remainingDependencies,\n      schema,\n      rootSchema,\n      formData\n    );\n  }\n  return schema;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<\n  S extends StrictRJSFSchema = RJSFSchema\n>(schema: S, additionallyRequired?: string[]) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param formData- The current formData to assist retrieving a schema\n * @returns - The schema with the dependent schema resolved into it\n */\nexport function withDependentSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  formData?: T\n) {\n  const { oneOf, ...dependentSchema } = retrieveSchema<T, S>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData\n  );\n  schema = mergeSchemas(schema, dependentSchema) as S;\n  // Since it does not contain oneOf, we return the original schema.\n  if (oneOf === undefined) {\n    return schema;\n  }\n  // Resolve $refs inside oneOf.\n  const resolvedOneOf = oneOf.map((subschema) => {\n    if (typeof subschema === \"boolean\" || !(REF_KEY in subschema)) {\n      return subschema;\n    }\n    return resolveReference<T, S>(\n      validator,\n      subschema as S,\n      rootSchema,\n      formData\n    );\n  });\n  return withExactlyOneSubschema<T, S>(\n    validator,\n    schema,\n    rootSchema,\n    dependencyKey,\n    resolvedOneOf,\n    formData\n  );\n}\n\n/** Returns a `schema` with the best choice from the `oneOf` options merged into it\n *\n * @param validator - An implementation of the `ValidatorType<T, S>` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns  The schema with the best choice of oneOf schemas merged into\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S[\"oneOf\"],\n  formData?: T\n): S {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === \"boolean\" || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: \"object\",\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      const { errors } = validator.validateFormData(formData, conditionSchema);\n      return errors.length === 0;\n    }\n    return false;\n  });\n\n  if (validSubschemas!.length !== 1) {\n    console.warn(\n      \"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\"\n    );\n    return schema;\n  }\n  const subschema: S = validSubschemas[0] as S;\n  const [dependentSubschema] = splitKeyElementFromObject(\n    dependencyKey,\n    subschema.properties as GenericObjectType\n  );\n  const dependentSchema = { ...subschema, properties: dependentSubschema };\n  return mergeSchemas(\n    schema,\n    retrieveSchema<T, S>(validator, dependentSchema, rootSchema, formData)\n  ) as S;\n}\n","import isConstant from \"../isConstant\";\nimport { RJSFSchema, StrictRJSFSchema, ValidatorType } from \"../types\";\nimport retrieveSchema from \"./retrieveSchema\";\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(validator: ValidatorType<T, S>, theSchema: S, rootSchema: S = {} as S) {\n  const schema = retrieveSchema<T, S>(\n    validator,\n    theSchema,\n    rootSchema,\n    undefined\n  );\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every(\n      (altSchemas) => typeof altSchemas !== \"boolean\" && isConstant(altSchemas)\n    );\n  }\n  return false;\n}\n","import { RJSFSchema, StrictRJSFSchema, ValidatorType } from \"../types\";\n\nimport isSelect from \"./isSelect\";\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(validator: ValidatorType<T, S>, schema: S, rootSchema?: S) {\n  if (\n    !schema.uniqueItems ||\n    !schema.items ||\n    typeof schema.items === \"boolean\"\n  ) {\n    return false;\n  }\n  return isSelect<T, S>(validator, schema.items as S, rootSchema);\n}\n","import get from \"lodash/get\";\nimport isEmpty from \"lodash/isEmpty\";\n\nimport {\n  ANY_OF_KEY,\n  DEFAULT_KEY,\n  DEPENDENCIES_KEY,\n  PROPERTIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n} from \"../constants\";\nimport findSchemaDefinition from \"../findSchemaDefinition\";\nimport getMatchingOption from \"./getMatchingOption\";\nimport getSchemaType from \"../getSchemaType\";\nimport isObject from \"../isObject\";\nimport isFixedItems from \"../isFixedItems\";\nimport mergeDefaultsWithFormData from \"../mergeDefaultsWithFormData\";\nimport mergeObjects from \"../mergeObjects\";\nimport {\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from \"../types\";\nimport isMultiSelect from \"./isMultiSelect\";\nimport retrieveSchema, { resolveDependencies } from \"./retrieveSchema\";\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== \"boolean\") {\n        return item as S;\n      }\n    }\n  } else if (\n    schema.items &&\n    !Array.isArray(schema.items) &&\n    typeof schema.items !== \"boolean\"\n  ) {\n    return schema.items as S;\n  }\n  if (\n    additionalItems !== AdditionalItemsHandling.Ignore &&\n    isObject(schema.additionalItems)\n  ) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the default state is desired\n * @param [parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n *          object properties.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  rawSchema: S,\n  parentDefaults?: T,\n  rootSchema: S = {} as S,\n  rawFormData?: T,\n  includeUndefinedValues: boolean | \"excludeObjectChildren\" = false\n): T | T[] | undefined {\n  const formData = isObject(rawFormData) ? rawFormData : {};\n  let schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(\n      defaults!,\n      schema.default as GenericObjectType\n    ) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    // Use referenced schema defaults for this node.\n    const refSchema = findSchemaDefinition<S>(schema[REF_KEY]!, rootSchema);\n    return computeDefaults<T, S>(\n      validator,\n      refSchema,\n      defaults,\n      rootSchema,\n      formData as T,\n      includeUndefinedValues\n    );\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies(\n      validator,\n      schema,\n      rootSchema,\n      formData\n    );\n    return computeDefaults<T, S>(\n      validator,\n      resolvedSchema,\n      defaults,\n      rootSchema,\n      formData as T,\n      includeUndefinedValues\n    );\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(\n        validator,\n        itemSchema,\n        Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rootSchema,\n        formData as T,\n        includeUndefinedValues\n      )\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    schema = schema.oneOf![\n      getMatchingOption(\n        validator,\n        isEmpty(formData) ? undefined : formData,\n        schema.oneOf as S[],\n        rootSchema\n      )\n    ] as S;\n  } else if (ANY_OF_KEY in schema) {\n    schema = schema.anyOf![\n      getMatchingOption(\n        validator,\n        isEmpty(formData) ? undefined : formData,\n        schema.anyOf as S[],\n        rootSchema\n      )\n    ] as S;\n  }\n\n  // Not defaults defined for this node, fallback to generic typed ones.\n  if (typeof defaults === \"undefined\") {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return Object.keys(schema.properties || {}).reduce(\n        (acc: GenericObjectType, key: string) => {\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          const computedDefault = computeDefaults<T, S>(\n            validator,\n            get(schema, [PROPERTIES_KEY, key]),\n            get(defaults, [key]),\n            rootSchema,\n            get(formData, [key]),\n            includeUndefinedValues === \"excludeObjectChildren\"\n              ? false\n              : includeUndefinedValues\n          );\n          if (includeUndefinedValues) {\n            acc[key] = computedDefault;\n          } else if (isObject(computedDefault)) {\n            // Store computedDefault if it's a non-empty object (e.g. not {})\n            if (!isEmpty(computedDefault)) {\n              acc[key] = computedDefault;\n            }\n          } else if (computedDefault !== undefined) {\n            // Store computedDefault if it's a defined primitive (e.g. true)\n            acc[key] = computedDefault;\n          }\n          return acc;\n        },\n        {}\n      ) as T;\n\n    case \"array\":\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(\n            schema,\n            AdditionalItemsHandling.Fallback,\n            idx\n          );\n          return computeDefaults<T, S>(validator, schemaItem, item, rootSchema);\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        defaults = rawFormData.map((item: T, idx: number) => {\n          return computeDefaults<T, S>(\n            validator,\n            schemaItem,\n            get(defaults, [idx]),\n            rootSchema,\n            item\n          );\n        }) as T[];\n      }\n      if (schema.minItems) {\n        if (!isMultiSelect<T>(validator, schema, rootSchema)) {\n          const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n          if (schema.minItems > defaultsLength) {\n            const defaultEntries: T[] = (defaults || []) as T[];\n            // populate the array with the defaults\n            const fillerSchema: S = getInnerSchemaForArrayItem<S>(\n              schema,\n              AdditionalItemsHandling.Invert\n            );\n            const fillerDefault = fillerSchema.default;\n            const fillerEntries: T[] = new Array(\n              schema.minItems - defaultsLength\n            ).fill(\n              computeDefaults<any>(\n                validator,\n                fillerSchema,\n                fillerDefault,\n                rootSchema\n              )\n            ) as T[];\n            // then fill up the rest with either the item default or empty, up to minItems\n            return defaultEntries.concat(fillerEntries);\n          }\n        }\n        return defaults ? defaults : [];\n      }\n  }\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n *          object properties.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | \"excludeObjectChildren\" = false\n) {\n  if (!isObject(theSchema)) {\n    throw new Error(\"Invalid schema: \" + theSchema);\n  }\n  const schema = retrieveSchema<T, S>(\n    validator,\n    theSchema,\n    rootSchema,\n    formData\n  );\n  const defaults = computeDefaults<T, S>(\n    validator,\n    schema,\n    undefined,\n    rootSchema,\n    formData,\n    includeUndefinedValues\n  );\n  if (\n    typeof formData === \"undefined\" ||\n    formData === null ||\n    (typeof formData === \"number\" && isNaN(formData))\n  ) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData);\n  }\n  return formData;\n}\n","import getUiOptions from \"./getUiOptions\";\nimport {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n} from \"./types\";\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://react-jsonschema-form.readthedocs.io/en/latest/usage/widgets/#hidden-widgets\n    \"widget\" in getUiOptions<T, S, F>(uiSchema) &&\n    getUiOptions<T, S, F>(uiSchema)[\"widget\"] !== \"hidden\"\n  );\n}\n","import { UI_WIDGET_KEY } from \"../constants\";\nimport {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from \"../types\";\nimport retrieveSchema from \"./retrieveSchema\";\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n) {\n  if (uiSchema[UI_WIDGET_KEY] === \"files\") {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T, S>(\n      validator,\n      schema.items as S,\n      rootSchema\n    );\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n  return false;\n}\n","import { UI_FIELD_KEY, UI_WIDGET_KEY } from \"../constants\";\nimport getSchemaType from \"../getSchemaType\";\nimport getUiOptions from \"../getUiOptions\";\nimport isCustomWidget from \"../isCustomWidget\";\nimport {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from \"../types\";\nimport isFilesArray from \"./isFilesArray\";\nimport isMultiSelect from \"./isMultiSelect\";\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n): boolean {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType(schema);\n\n  if (schemaType === \"array\") {\n    displayLabel =\n      isMultiSelect<T, S>(validator, schema, rootSchema) ||\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === \"object\") {\n    displayLabel = false;\n  }\n  if (schemaType === \"boolean\" && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n","import isEmpty from \"lodash/isEmpty\";\n\nimport mergeObjects from \"../mergeObjects\";\nimport {\n  ErrorSchema,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidationData,\n  ValidatorType,\n} from \"../types\";\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function mergeValidationData<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(\n      oldErrorSchema,\n      additionalErrorSchema,\n      true\n    ) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n","import get from \"lodash/get\";\n\nimport {\n  ALL_OF_KEY,\n  DEPENDENCIES_KEY,\n  ID_KEY,\n  ITEMS_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n} from \"../constants\";\nimport isObject from \"../isObject\";\nimport {\n  IdSchema,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from \"../types\";\nimport retrieveSchema from \"./retrieveSchema\";\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = \"root\",\n  idSeparator = \"_\"\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S>(\n      validator,\n      schema,\n      rootSchema,\n      formData\n    );\n    return toIdSchema<T>(\n      validator,\n      _schema,\n      id,\n      rootSchema,\n      formData,\n      idPrefix,\n      idSeparator\n    );\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchema<T, S>(\n      validator,\n      get(schema, ITEMS_KEY) as S,\n      id,\n      rootSchema,\n      formData,\n      idPrefix,\n      idSeparator\n    );\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (schema.type === \"object\" && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchema<T, S>(\n        validator,\n        isObject(field) ? field : {},\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        idPrefix,\n        idSeparator\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n","import get from \"lodash/get\";\nimport set from \"lodash/set\";\n\nimport {\n  ALL_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from \"../constants\";\nimport {\n  PathSchema,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from \"../types\";\nimport retrieveSchema from \"./retrieveSchema\";\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema\n>(\n  validator: ValidatorType<T, S>,\n  schema: S,\n  name = \"\",\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S>(\n      validator,\n      schema,\n      rootSchema,\n      formData\n    );\n    return toPathSchema<T, S>(validator, _schema, name, rootSchema, formData);\n  }\n\n  const pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, \"\"),\n  } as PathSchema;\n\n  if (\n    ADDITIONAL_PROPERTIES_KEY in schema &&\n    schema[ADDITIONAL_PROPERTIES_KEY] !== false\n  ) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    formData.forEach((element, i: number) => {\n      pathSchema[i] = toPathSchema<T>(\n        validator,\n        schema.items as RJSFSchema,\n        `${name}.${i}`,\n        rootSchema,\n        element\n      );\n    });\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchema<T, S>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property])\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n","import deepEquals from \"./deepEquals\";\nimport {\n  ErrorSchema,\n  FormContextType,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from \"./types\";\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  toIdSchema,\n  toPathSchema,\n} from \"./schema\";\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator` or `rootSchema` to each method. Since both the `validator`\n * and `rootSchema` generally does not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n> implements SchemaUtilsType<T, S>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S>;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   */\n  constructor(validator: ValidatorType<T, S>, rootSchema: S) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S>,\n    rootSchema: S\n  ): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return (\n      this.validator !== validator || !deepEquals(this.rootSchema, rootSchema)\n    );\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | \"excludeObjectChildren\" = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S>(\n      this.validator,\n      schema,\n      formData,\n      this.rootSchema,\n      includeUndefinedValues\n    );\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return getDisplayLabel<T, S, F>(\n      this.validator,\n      schema,\n      uiSchema,\n      this.rootSchema\n    );\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @returns - The index of the matched option or 0 if none is available\n   */\n  getMatchingOption(formData: T, options: S[]) {\n    return getMatchingOption<T, S>(\n      this.validator,\n      formData,\n      options,\n      this.rootSchema\n    );\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(\n      this.validator,\n      schema,\n      uiSchema,\n      this.rootSchema\n    );\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   */\n  mergeValidationData(\n    validationData: ValidationData<T>,\n    additionalErrorSchema?: ErrorSchema<T>\n  ): ValidationData<T> {\n    return mergeValidationData<T, S>(\n      this.validator,\n      validationData,\n      additionalErrorSchema\n    );\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData: T) {\n    return retrieveSchema<T, S>(\n      this.validator,\n      schema,\n      this.rootSchema,\n      rawFormData\n    );\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(\n    schema: S,\n    id?: string | null,\n    formData?: T,\n    idPrefix = \"root\",\n    idSeparator = \"_\"\n  ): IdSchema<T> {\n    return toIdSchema<T, S>(\n      this.validator,\n      schema,\n      id,\n      this.rootSchema,\n      formData,\n      idPrefix,\n      idSeparator\n    );\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S>(\n      this.validator,\n      schema,\n      name,\n      this.rootSchema,\n      formData\n    );\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S>, rootSchema: S): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema);\n}\n","/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(\",\");\n  // Split params\n  const params: string[] = splitted[0].split(\";\");\n  // Get mime-type from params\n  const type: string = params[0].replace(\"data:\", \"\");\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split(\"=\")[0] === \"name\";\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  const binary = atob(splitted[1]);\n  const array = [];\n  for (let i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  }\n  // Create the blob object\n  const blob = new window.Blob([new Uint8Array(array)], { type });\n\n  return { blob, name };\n}\n","import cloneDeep from \"lodash/cloneDeep\";\nimport get from \"lodash/get\";\nimport set from \"lodash/set\";\n\nimport { ErrorSchema } from \"./types\";\nimport { ERRORS_KEY } from \"./constants\";\n\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\n * get the result and/or reset all the errors back to an initial set and start again.\n */\nexport default class ErrorSchemaBuilder<T = any> {\n  /** The error schema being built\n   *\n   * @private\n   */\n  private errorSchema: ErrorSchema<T> = {};\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   */\n  constructor(initialSchema?: ErrorSchema<T>) {\n    this.resetAllErrors(initialSchema);\n  }\n\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\n   */\n  get ErrorSchema() {\n    return this.errorSchema;\n  }\n\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The error block for the given `pathOfError` or the root if not provided\n   * @private\n   */\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\n    const hasPath =\n      (Array.isArray(pathOfError) && pathOfError.length > 0) ||\n      typeof pathOfError === \"string\";\n    let errorBlock: ErrorSchema = hasPath\n      ? get(this.errorSchema, pathOfError)\n      : this.errorSchema;\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n    return errorBlock;\n  }\n\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    let errorsList = get(errorBlock, ERRORS_KEY);\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      errorsList.push(...errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n    return this;\n  }\n\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n    const listToAdd = Array.isArray(errorOrList)\n      ? [...errorOrList]\n      : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\n   * the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  clearErrors(pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  }\n}\n","import { RangeSpecType, StrictRJSFSchema } from \"./types\";\nimport { RJSFSchema } from \"./types\";\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n","import rangeSpec from \"./rangeSpec\";\nimport {\n  FormContextType,\n  InputPropsType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UIOptionsType,\n} from \"./types\";\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, S, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || \"text\",\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === \"number\") {\n      inputProps.type = \"number\";\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = \"any\";\n      }\n    } else if (schema.type === \"integer\") {\n      inputProps.type = \"number\";\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n","import { SUBMIT_BTN_OPTIONS_KEY } from \"./constants\";\nimport getUiOptions from \"./getUiOptions\";\nimport {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  UISchemaSubmitButtonOptions,\n} from \"./types\";\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: \"Submit\",\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[\n      SUBMIT_BTN_OPTIONS_KEY\n    ] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n","import {\n  FormContextType,\n  TemplatesType,\n  Registry,\n  UIOptionsType,\n  StrictRJSFSchema,\n  RJSFSchema,\n} from \"./types\";\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, S, F>,\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  name: Name,\n  registry: Registry<T, S, F>,\n  uiOptions: UIOptionsType<T, S, F> = {}\n): TemplatesType<T, S, F>[Name] {\n  const { templates } = registry;\n  if (name === \"ButtonTemplates\") {\n    return templates[name];\n  }\n  return (\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) ||\n    templates[name]\n  );\n}\n","import React from \"react\";\nimport ReactIs from \"react-is\";\nimport get from \"lodash/get\";\nimport set from \"lodash/set\";\n\nimport {\n  FormContextType,\n  RJSFSchema,\n  Widget,\n  RegistryWidgetsType,\n  StrictRJSFSchema,\n} from \"./types\";\nimport getSchemaType from \"./getSchemaType\";\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\",\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\",\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\",\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(AWidget: Widget<T, S, F>) {\n  let MergedWidget: Widget<T, S, F> = get(AWidget, \"MergedWidget\");\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions =\n      (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, \"MergedWidget\", MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === \"function\" ||\n    (widget && ReactIs.isForwardRef(React.createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === \"string\") {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n","import getWidget from \"./getWidget\";\nimport {\n  FormContextType,\n  RegistryWidgetsType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  Widget,\n} from \"./types\";\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  widget: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (\n      err.message &&\n      (err.message.startsWith(\"No widget\") ||\n        err.message.startsWith(\"Unsupported widget\"))\n    ) {\n      return false;\n    }\n    throw e;\n  }\n}\n","/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n","import { CONST_KEY, ENUM_KEY } from \"./constants\";\nimport { RJSFSchema, StrictRJSFSchema } from \"./types\";\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n) {\n  if (\n    ENUM_KEY in schema &&\n    Array.isArray(schema.enum) &&\n    schema.enum.length === 1\n  ) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error(\"schema cannot be inferred as a constant\");\n}\n","import toConstant from \"./toConstant\";\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from \"./types\";\n\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value.\n *\n * @param schema - The schema from which to extract the options list\n * @returns - The list of options from the schema\n */\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): EnumOptionsType<S>[] | undefined {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== \"production\") {\n    console.warn(\n      \"The enumNames property is deprecated and may be removed in a future major release.\"\n    );\n  }\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label =\n        (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) ||\n        String(value);\n      return { label, value };\n    });\n  }\n  const altSchemas = schema.oneOf || schema.anyOf;\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef) => {\n      const aSchema = aSchemaDef as S;\n      const value = toConstant(aSchema);\n      const label = aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n","import { GenericObjectType } from \"./types\";\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(\n  properties: string[],\n  order?: string[]\n): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1\n      ? `properties '${arr.join(\"', '\")}'`\n      : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter(\n    (prop) => prop === \"*\" || propertyHash[prop]\n  );\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf(\"*\");\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\n        `uiSchema order list does not contain ${errorPropList(rest)}`\n      );\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n","/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = \"0\" + s;\n  }\n  return s;\n}\n","import { DateObject } from \"./types\";\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(\n  dateString?: string,\n  includeTime = true\n): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n","import get from \"lodash/get\";\n\nimport {\n  FormContextType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UIOptionsType,\n} from \"./types\";\nimport asNumber from \"./asNumber\";\nimport guessType from \"./guessType\";\n\nconst nums = new Set<any>([\"number\", \"integer\"]);\n\n/** Returns the real value for a select widget due to a silly limitation in the DOM which causes option change event\n * values to always be retrieved as strings. Uses the `schema` to help determine the value's true type. If the value is\n * an empty string, then the `emptyValue` from the `options` is returned, falling back to undefined.\n *\n * @param schema - The schema to used to determine the value's true type\n * @param [value] - The value to convert\n * @param [options] - The UIOptionsType from which to potentially extract the emptyValue\n * @returns - The `value` converted to the proper type\n */\nexport default function processSelectValue<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(schema: S, value?: any, options?: UIOptionsType<T, S, F>) {\n  const { enum: schemaEnum, type, items } = schema;\n  if (value === \"\") {\n    return options && options.emptyValue !== undefined\n      ? options.emptyValue\n      : undefined;\n  }\n  if (type === \"array\" && items && nums.has(get(items, \"type\"))) {\n    return value.map(asNumber);\n  }\n  if (type === \"boolean\") {\n    return value === \"true\";\n  }\n  if (nums.has(type)) {\n    return asNumber(value);\n  }\n\n  // If type is undefined, but an enum is present, try and infer the type from\n  // the enum values\n  if (Array.isArray(schemaEnum)) {\n    if (schemaEnum.every((x: any) => nums.has(guessType(x)))) {\n      return asNumber(value);\n    }\n    if (schemaEnum.every((x: any) => guessType(x) === \"boolean\")) {\n      return value === \"true\";\n    }\n  }\n\n  return value;\n}\n","import { RJSFSchema, StrictRJSFSchema } from \"./types\";\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue<\n  S extends StrictRJSFSchema = RJSFSchema\n>(schema: S): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: S[\"additionalProperties\"]) =>\n      schemaRequiresTrueValue(subSchema as S);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n","import React from \"react\";\n\nimport deepEquals from \"./deepEquals\";\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(\n  component: React.Component,\n  nextProps: any,\n  nextState: any\n) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n","import { DateObject } from \"./types\";\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n","import pad from \"./pad\";\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return \"\";\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n"],"names":["isObject","thing","File","Date","Array","isArray","allowAdditionalItems","schema","additionalItems","console","warn","asNumber","value","undefined","test","n","Number","valid","isNaN","ADDITIONAL_PROPERTY_FLAG","ADDITIONAL_PROPERTIES_KEY","ALL_OF_KEY","ANY_OF_KEY","CONST_KEY","DEFAULT_KEY","DEFINITIONS_KEY","DEPENDENCIES_KEY","ENUM_KEY","ERRORS_KEY","ID_KEY","ITEMS_KEY","NAME_KEY","ONE_OF_KEY","PROPERTIES_KEY","REQUIRED_KEY","SUBMIT_BTN_OPTIONS_KEY","REF_KEY","RJSF_ADDITONAL_PROPERTIES_FLAG","UI_FIELD_KEY","UI_WIDGET_KEY","UI_OPTIONS_KEY","getUiOptions","uiSchema","Object","keys","filter","key","indexOf","reduce","options","error","substring","canExpand","formData","additionalProperties","expandable","maxProperties","length","deepEquals","a","b","isEqualWith","obj","other","splitKeyElementFromObject","object","remaining","omit","findSchemaDefinition","$ref","rootSchema","ref","startsWith","decodeURIComponent","Error","current","jsonpointer","get","theRef","subSchema","getMatchingOption","validator","i","option","properties","requiresAnyOf","anyOf","map","required","augmentedSchema","shallowClone","allOf","slice","push","assign","isValid","guessType","getSchemaType","type","includes","find","isFixedItems","items","every","item","mergeDefaultsWithFormData","defaults","defaultsArray","mapped","idx","acc","mergeObjects","obj1","obj2","concatArrays","left","right","toMerge","result","concat","isConstant","mergeSchemas","union","resolveCondition","expression","then","otherwise","resolvedSchemaLessConditional","_excluded","conditionalSchema","retrieveSchema","resolveSchema","resolveReference","resolvedSchema","resolveDependencies","allOfSubschema","$refSchema","localSchema","stubExistingAdditionalProperties","theSchema","aFormData","forEach","set","rawFormData","mergeAllOf","deep","e","resolvedSchemaWithoutAllOf","hasAdditionalProperties","dependencies","remainingSchema","oneOf","processDependencies","dependencyKey","remainingDependencies","dependencyValue","withDependentProperties","withDependentSchema","additionallyRequired","from","Set","dependentSchema","resolvedOneOf","subschema","withExactlyOneSubschema","validSubschemas","conditionPropertySchema","conditionSchema","validateFormData","errors","dependentSubschema","isSelect","altSchemas","isMultiSelect","uniqueItems","AdditionalItemsHandling","getInnerSchemaForArrayItem","Ignore","computeDefaults","rawSchema","parentDefaults","includeUndefinedValues","refSchema","itemSchema","isEmpty","computedDefault","schemaItem","Fallback","minItems","defaultsLength","defaultEntries","fillerSchema","Invert","fillerDefault","fillerEntries","fill","getDefaultFormState","isCustomWidget","isFilesArray","itemsSchema","format","getDisplayLabel","uiOptions","label","displayLabel","schemaType","mergeValidationData","validationData","additionalErrorSchema","oldErrors","oldErrorSchema","errorSchema","toErrorList","toIdSchema","id","idPrefix","idSeparator","_schema","$id","idSchema","name","field","fieldId","toPathSchema","pathSchema","replace","element","property","SchemaUtils","getValidator","doesSchemaUtilsDiffer","createSchemaUtils","dataURItoBlob","dataURI","splitted","split","params","param","binary","atob","array","charCodeAt","blob","window","Blob","Uint8Array","ErrorSchemaBuilder","initialSchema","resetAllErrors","getOrCreateErrorBlock","pathOfError","hasPath","errorBlock","cloneDeep","addErrors","errorOrList","errorsList","setErrors","listToAdd","clearErrors","rangeSpec","spec","multipleOf","step","minimum","min","maximum","max","getInputProps","defaultType","autoDefaultStepAny","inputProps","inputType","autocomplete","autoComplete","DEFAULT_OPTIONS","props","disabled","submitText","norender","getSubmitButtonOptions","getTemplate","registry","templates","widgetMap","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","color","file","number","updown","range","integer","checkboxes","files","mergeWidgetOptions","AWidget","MergedWidget","defaultOptions","defaultProps","React","createElement","getWidget","widget","registeredWidgets","ReactIs","isForwardRef","isMemo","registeredWidget","hasWidget","err","message","localToUTC","dateString","toJSON","toConstant","optionsList","schemaWithEnumNames","enumNames","process","env","NODE_ENV","String","aSchemaDef","aSchema","title","orderProperties","order","arrayToHash","arr","prev","curr","errorPropList","join","propertyHash","orderFiltered","prop","orderHash","rest","restIndex","lastIndexOf","complete","splice","pad","num","width","s","parseDateString","includeTime","year","month","day","hour","minute","second","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","nums","processSelectValue","schemaEnum","emptyValue","has","x","schemaRequiresTrueValue","schemaSome","some","shouldRender","component","nextProps","nextState","state","toDateString","dateObject","time","utcTime","UTC","utcToLocal","jsonDate","yyyy","getFullYear","MM","getMonth","dd","getDate","hh","getHours","mm","getMinutes","ss","getSeconds","SSS","getMilliseconds"],"mappings":"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"}